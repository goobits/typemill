//! Go Language Plugin for TypeMill
//!
//! This crate provides complete Go language support, implementing the
//! `LanguagePlugin` trait from `mill_plugin_api`.

mod constants;
pub mod import_support;
pub mod lsp_installer;
mod manifest;
pub mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod workspace_support;

use async_trait::async_trait;
use mill_foundation::protocol::EditPlan;
use mill_foundation::protocol::ImportGraph;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{
    ImportAnalyzer, LanguagePlugin, ManifestData, ManifestUpdater, ModuleReference,
    ModuleReferenceScanner, ParsedSource, PluginError, PluginResult, ReferenceKind,
    RefactoringProvider, ScanScope,
};
use std::path::Path;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: GoPlugin,
    name: "go",
    extensions: ["go"],
    manifest: "go.mod",
    lsp_command: "gopls",
    lsp_args: [""],
    source_dir: ".",
    entry_point: "main.go",
    module_separator: "/",
    capabilities: [with_imports, with_project_factory, with_workspace],
    fields: {
        import_support: import_support::GoImportSupport,
        project_factory: project_factory::GoProjectFactory,
        workspace_support: workspace_support::GoWorkspaceSupport,
        lsp_installer: lsp_installer::GoLspInstaller,
    },
    doc: "Go language plugin implementation providing comprehensive Go language support"
}

#[async_trait]
impl LanguagePlugin for GoPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        let symbols = parser::extract_symbols(source)?;

        Ok(ParsedSource {
            data: serde_json::json!({
                "language": "go",
                "symbols_count": symbols.len()
            }),
            symbols,
        })
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::load_go_mod(path).await
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            refactoring_provider: RefactoringProvider,
            module_reference_scanner: ModuleReferenceScanner,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        }
    }
}

#[async_trait]
impl ManifestUpdater for GoPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = tokio::fs::read_to_string(manifest_path)
            .await
            .map_err(|e| PluginError::internal(e.to_string()))?;
        manifest::update_dependency(&content, old_name, new_name, new_version)
    }

    fn generate_manifest(&self, package_name: &str, _dependencies: &[String]) -> String {
        manifest::generate_manifest(package_name, constants::DEFAULT_GO_VERSION)
    }
}

impl ImportAnalyzer for GoPlugin {
    fn build_import_graph(&self, file_path: &Path) -> PluginResult<ImportGraph> {
        let content =
            std::fs::read_to_string(file_path).map_err(|e| PluginError::internal(e.to_string()))?;
        parser::analyze_imports(&content, Some(file_path))
    }
}

impl ModuleReferenceScanner for GoPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: ScanScope,
    ) -> PluginResult<Vec<ModuleReference>> {
        let mut references = Vec::new();
        let import_pattern = (constants::MODULE_IN_IMPORT_PATTERN)(module_name);
        let import_re = regex::Regex::new(&import_pattern)
            .map_err(|e| PluginError::internal(format!("Invalid regex: {}", e)))?;

        for (i, line) in content.lines().enumerate() {
            let line_num = i + 1; // Convert to 1-indexed line numbering

            // Only scan lines that look like imports (context-aware)
            // This avoids false positives in string literals or comments
            let trimmed = line.trim();
            if trimmed.starts_with("import") || (trimmed.starts_with('"') && i > 0) {
                for mat in import_re.find_iter(line) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: mat.start(),
                        length: mat.len(),
                        text: mat.as_str().to_string(),
                        kind: ReferenceKind::Declaration,
                    });
                }
            }

            // Scan for qualified paths like `fmt.Println`
            if scope == ScanScope::All || scope == ScanScope::QualifiedPaths {
                // Skip lines that are comments
                if trimmed.starts_with("//") || trimmed.starts_with("/*") {
                    continue;
                }

                // Strip inline comments before matching
                let code_only = line.split("//").next().unwrap_or(line);

                let qualified_pattern = (constants::QUALIFIED_PATH_PATTERN)(module_name);
                let qualified_re = regex::Regex::new(&qualified_pattern)
                    .map_err(|e| PluginError::internal(format!("Invalid regex: {}", e)))?;

                for mat in qualified_re.find_iter(code_only) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: mat.start(),
                        length: mat.len(),
                        text: mat.as_str().to_string(),
                        kind: ReferenceKind::QualifiedPath,
                    });
                }
            }
        }

        Ok(references)
    }
}

#[async_trait]
impl RefactoringProvider for GoPlugin {
    // extract_function
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        refactoring::plan_extract_function(source, start_line, end_line, function_name, file_path)
    }

    // inline_variable
    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        line: u32,
        col: u32,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        refactoring::plan_inline_variable(source, line, col, file_path)
    }

    // extract_variable
    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::{
        CreatePackageConfig, LanguagePlugin, LspInstaller, Template, WorkspaceSupport,
    };
    use tempfile::tempdir;

    #[test]
    fn test_go_metadata() {
        let plugin = GoPlugin::default();
        let metadata = plugin.metadata();
        assert_eq!(metadata.name, "go");
    }

    #[test]
    fn test_go_capabilities() {
        let plugin = GoPlugin::default();
        let caps = plugin.capabilities();
        assert!(caps.imports);
        assert!(caps.workspace);
    }

    #[test]
    fn test_create_package() {
        let plugin = GoPlugin::default();
        let factory = plugin.project_factory().unwrap();
        let tmp_dir = tempdir().unwrap();
        let config = CreatePackageConfig {
            package_path: "my-go-app".to_string(),
            workspace_root: tmp_dir.path().to_str().unwrap().to_string(),
            add_to_workspace: false,
            package_type: mill_plugin_api::PackageType::Binary,
            template: Template::Minimal,
        };

        let result = factory.create_package(&config).unwrap();
        assert_eq!(result.created_files.len(), 2);
        assert!(result.created_files[0].contains("go.mod"));
        assert!(result.created_files[1].contains("main.go"));

        let go_mod_content =
            std::fs::read_to_string(tmp_dir.path().join("my-go-app/go.mod")).unwrap();
        assert!(go_mod_content.contains("module my-go-app"));
    }

    #[test]
    fn test_import_advanced_support_returns_some() {
        let plugin = GoPlugin::default();
        assert!(plugin.import_advanced_support().is_some());
    }

    #[tokio::test]
    async fn test_refactoring_provider_extract_function() {
        let plugin = GoPlugin::default();
        let provider = plugin.refactoring_provider().unwrap();
        let source = "package main\n\nfunc main() {\n\tprintln(\"hello\")\n}";
        let plan = provider
            .plan_extract_function(source, 3, 3, "greet", "main.go")
            .await
            .unwrap();
        assert_eq!(plan.edits.len(), 2);
    }

    #[tokio::test]
    async fn test_refactoring_provider_inline_variable() {
        let plugin = GoPlugin::default();
        let provider = plugin.refactoring_provider().unwrap();
        let source = "package main\n\nfunc main() {\n\tconst x = \"hello\"\n\tprintln(x)\n}";
        let plan = provider
            .plan_inline_variable(source, 3, 8, "main.go")
            .await
            .unwrap();
        assert_eq!(plan.edits.len(), 2);
    }

    #[tokio::test]
    async fn test_refactoring_provider_extract_variable() {
        let plugin = GoPlugin::default();
        let provider = plugin.refactoring_provider().unwrap();
        let source = "package main\n\nfunc main() {\n\tprintln(\"hello\")\n}";
        let plan = provider
            .plan_extract_variable(source, 3, 9, 3, 16, Some("greeting".to_string()), "main.go")
            .await
            .unwrap();
        assert_eq!(plan.edits.len(), 2);
    }

    #[test]
    fn test_workspace_support_add_and_list_members() {
        let support = workspace_support::GoWorkspaceSupport;
        let initial_content = "go 1.21\n";
        let with_member = support.add_workspace_member(initial_content, "my-go-app");
        assert!(with_member.contains("use ./my-go-app"));
        let members = support.list_workspace_members(&with_member);
        assert_eq!(members, vec!["my-go-app"]);
    }

    #[test]
    fn test_module_reference_scanner() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"fmt\"";
        let refs = scanner
            .scan_references(content, "fmt", ScanScope::All)
            .unwrap();
        assert_eq!(refs.len(), 1);
        assert_eq!(refs[0].line, 3); // Line 3 (1-indexed): import "fmt"
    }

    #[test]
    fn test_import_analyzer() {
        let plugin = GoPlugin::default();
        let analyzer = plugin.import_analyzer().unwrap();
        let tmp_dir = tempdir().unwrap();
        let file_path = tmp_dir.path().join("main.go");
        std::fs::write(&file_path, "package main\n\nimport \"fmt\"").unwrap();
        let graph = analyzer.build_import_graph(&file_path).unwrap();
        assert_eq!(graph.imports.len(), 1);
        assert_eq!(graph.imports[0].module_path, "fmt");
    }

    #[tokio::test]
    async fn test_manifest_updater() {
        let plugin = GoPlugin::default();
        let updater = plugin.manifest_updater().unwrap();
        let tmp_dir = tempdir().unwrap();
        let file_path = tmp_dir.path().join("go.mod");
        std::fs::write(&file_path, "module my-go-app\n\nrequire example.com/pkg v1.2.3")
            .unwrap();
        let updated = updater
            .update_dependency(
                &file_path,
                "example.com/pkg",
                "example.com/newpkg",
                Some("v1.2.4"),
            )
            .await
            .unwrap();
        assert!(updated.contains("example.com/newpkg v1.2.4"));
    }

    #[tokio::test]
    async fn test_lsp_installer() {
        let installer = lsp_installer::GoLspInstaller;
        // This test can't easily install the real gopls in a hermetic way.
        // We'll just check that the name is correct. In a real CI environment,
        // we would mock the `go install` command.
        assert_eq!(installer.lsp_name(), "gopls");
    }

    // ========================================================================
    // ERROR PATH TESTS
    // ========================================================================

    #[tokio::test]
    async fn test_parse_invalid_source() {
        let plugin = GoPlugin::default();
        // Malformed Go code should still parse symbols gracefully
        let result = plugin.parse("this is not valid go code {{{").await;
        assert!(result.is_ok(), "Parser should handle invalid source gracefully");
    }

    #[tokio::test]
    async fn test_analyze_nonexistent_manifest() {
        let plugin = GoPlugin::default();
        let result = plugin.analyze_manifest(Path::new("/nonexistent/go.mod")).await;
        assert!(result.is_err(), "Should error on nonexistent manifest");
    }

    #[test]
    fn test_scan_references_with_empty_module_name() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"fmt\"";
        let result = scanner.scan_references(content, "", ScanScope::All);
        assert!(result.is_ok(), "Should handle empty module name");
    }

    #[test]
    fn test_module_reference_scanner_with_invalid_regex_chars() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"fmt\"";
        // Test with special regex characters (should be escaped)
        let result = scanner.scan_references(content, "fmt.+*", ScanScope::All);
        assert!(result.is_ok(), "Should handle special regex characters");
    }

    // ========================================================================
    // EDGE CASE TESTS
    // ========================================================================

    #[test]
    fn test_scan_references_with_unicode_module_names() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"日本語/パッケージ\"\n\n日本語.Function()";
        let refs = scanner.scan_references(content, "日本語", ScanScope::All).unwrap();
        // Should find at least the qualified path (even if import detection is limited)
        assert!(!refs.is_empty(), "Should find Unicode module names in qualified paths");
    }

    #[tokio::test]
    async fn test_parse_extremely_long_line() {
        let plugin = GoPlugin::default();
        // Create a very long line (>10,000 chars)
        let long_string = "a".repeat(15000);
        let source = format!("package main\n\nconst x = \"{}\"\n", long_string);
        let result = plugin.parse(&source).await;
        assert!(result.is_ok(), "Should handle extremely long lines");
    }

    #[tokio::test]
    async fn test_parse_no_newlines() {
        let plugin = GoPlugin::default();
        let source = "package main func main() { fmt.Println(\"Hello\") }";
        let result = plugin.parse(source).await;
        assert!(result.is_ok(), "Should handle source without newlines");
    }

    #[test]
    fn test_scan_references_with_mixed_line_endings() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        // Mix CRLF and LF
        let content = "package main\r\nimport \"fmt\"\nimport \"strings\"";
        let refs = scanner.scan_references(content, "fmt", ScanScope::All).unwrap();
        assert_eq!(refs.len(), 1, "Should handle mixed line endings");
    }

    #[test]
    fn test_scan_references_excludes_comments() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "// fmt.Println should not match\n/* fmt.Println */\nfmt.Println(\"real\")";
        let refs = scanner.scan_references(content, "fmt", ScanScope::QualifiedPaths).unwrap();
        // Should only find the non-comment reference
        assert_eq!(refs.len(), 1, "Should exclude comments from qualified path matching");
    }

    // ========================================================================
    // PERFORMANCE TESTS
    // ========================================================================

    #[test]
    fn test_parse_large_file() {
        use std::time::Instant;
        let plugin = GoPlugin::default();

        // Create a large Go file (~100KB)
        let mut large_source = String::from("package main\n\n");
        for i in 0..5000 {
            large_source.push_str(&format!("func function{}() {{}}\n", i));
        }

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new().unwrap().block_on(async {
            plugin.parse(&large_source).await
        });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        assert!(duration.as_secs() < 5, "Should parse large file within 5 seconds, took {:?}", duration);
    }

    #[test]
    fn test_scan_many_references_performance() {
        use std::time::Instant;
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();

        // Create content with many references
        let mut content = String::from("package main\n\n");
        for _ in 0..10000 {
            content.push_str("fmt.Println(\"test\")\n");
        }

        let start = Instant::now();
        let refs = scanner.scan_references(&content, "fmt", ScanScope::All).unwrap();
        let duration = start.elapsed();

        assert_eq!(refs.len(), 10000, "Should find all references");
        // Relaxed timing for CI environments (10s threshold)
        assert!(duration.as_secs() < 10, "Should scan 10K references within 10 seconds, took {:?}", duration);
    }

    // ========================================================================
    // ROBUSTNESS TESTS
    // ========================================================================

    #[tokio::test]
    async fn test_parse_empty_source() {
        let plugin = GoPlugin::default();
        let result = plugin.parse("").await;
        assert!(result.is_ok(), "Should handle empty source");
        assert_eq!(result.unwrap().symbols.len(), 0, "Empty source should have no symbols");
    }

    #[tokio::test]
    async fn test_parse_whitespace_only() {
        let plugin = GoPlugin::default();
        let result = plugin.parse("   \n\n\t\t\n   ").await;
        assert!(result.is_ok(), "Should handle whitespace-only source");
    }

    #[test]
    fn test_scan_references_with_null_bytes() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\x00import \"fmt\"\n";
        let result = scanner.scan_references(content, "fmt", ScanScope::All);
        // Should not panic, may or may not find the import
        assert!(result.is_ok(), "Should handle null bytes gracefully");
    }
}